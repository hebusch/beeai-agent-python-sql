"""
FixedPythonTool: Tool que hace requests HTTP directas al code interpreter.

Este tool evita la validación estricta del PythonTool del framework,
haciendo requests directas al endpoint que SÍ acepta 'Language.PYTHON'.
"""

import hashlib
import httpx
import shutil
import os
from typing import Any

from beeai_framework.context import RunContext
from beeai_framework.emitter import Emitter
from beeai_framework.tools import StringToolOutput, Tool, ToolRunOptions, ToolError
from beeai_framework.tools.code import LocalPythonStorage
from pydantic import BaseModel, Field


class FixedPythonToolInput(BaseModel):
    """Input schema para el code interpreter."""
    
    code: str = Field(
        description="Python code to execute. Must be written in English. No special characters. No accents. Can read CSV files from DB2 queries."
    )
    input_files: list[str] = Field(
        default_factory=list,
        description="List of input file paths to make accessible to the code (e.g., '/workspace/abc123' from DB2 CSV output). Files will be available in /workspace/ directory."
    )


class FixedPythonTool(Tool[FixedPythonToolInput, ToolRunOptions, StringToolOutput]):
    """
    Tool que ejecuta código Python haciendo requests HTTP directas al code interpreter.
    
    Este approach evita la validación estricta del PythonTool del framework
    y permite que el agente pase 'Language.PYTHON' directamente.
    """
    
    name = "Python"
    description = """A tool for writing and executing Python code for data analysis and visualization.

This tool can:
- Read CSV files generated by DB2Tool queries (use input_files parameter)
- Read MULTIPLE CSV files from different DB2 queries for correlation analysis
- Create visualizations with matplotlib, seaborn
- Perform statistical analysis with pandas, numpy, scipy
- Generate reports and summaries

Available libraries:
- pandas: Data manipulation and analysis
- matplotlib, seaborn: Data visualization
- numpy, scipy: Scientific computing
- scikit-learn: Machine learning

CRITICAL RULES:
1. DB2Tool saves each query to a UNIQUE CSV with timestamp (e.g., db2_results_20251113_143022.csv)
2. COPY THE EXACT FILENAME from DB2Tool output message
3. Use input_files parameter with the exact filename(s)
4. For multiple queries, use multiple files: input_files=['file1.csv', 'file2.csv']
5. Each file is available at /workspace/filename
6. Create visualizations and save as PNG with plt.savefig()

EXAMPLES:
Single file: input_files=['/workspace/db2_results_20251113_143022.csv']
Multiple files: input_files=['/workspace/db2_results_20251113_143022.csv', '/workspace/db2_results_20251113_143055.csv']"""
    input_schema = FixedPythonToolInput
    
    def __init__(
        self, 
        code_interpreter_url: str, 
        storage: LocalPythonStorage | None = None, 
        **kwargs: Any
    ) -> None:
        """
        Inicializa el tool con la URL del code interpreter.
        
        Args:
            code_interpreter_url: URL del code interpreter (ej: http://localhost:50082)
            storage: LocalPythonStorage para copiar archivos generados
            **kwargs: Argumentos adicionales para Tool
        """
        super().__init__(**kwargs)
        self.code_interpreter_url = code_interpreter_url.rstrip('/')
        self.execute_endpoint = f"{self.code_interpreter_url}/v1/execute"
        self.storage = storage
    
    def _create_emitter(self) -> Emitter:
        """Crea un emitter para el tool."""
        return Emitter.root().child(
            namespace=["tool", "direct", "python"],
            creator=self,
        )
    
    async def _run(
        self,
        tool_input: FixedPythonToolInput,
        options: ToolRunOptions | None,
        context: RunContext,
    ) -> StringToolOutput:
        """
        Ejecuta el código Python haciendo una request HTTP al code interpreter.
        
        Args:
            tool_input: Input con código y configuración
            options: Opciones de ejecución (no usadas)
            context: Contexto de ejecución
            
        Returns:
            StringToolOutput con el resultado de la ejecución
        """
        try:
            # Preparar el payload para el code interpreter
            payload = {
                "source_code": tool_input.code,
            }
            
            # Si hay archivos de input, construir el dict de files
            # Formato esperado: Dict[AbsolutePath, Hash]
            # donde AbsolutePath es la ruta en el pod (ej: /workspace/db2_results.csv)
            # y Hash es el hash del archivo
            if tool_input.input_files and self.storage:
                files_dict = {}
                for file_path in tool_input.input_files:
                    # Para db2_results.csv, necesitamos calcular el hash del archivo
                    # y copiarlo al interpreter_working_dir
                    filename = os.path.basename(file_path)
                    
                    # Construir la ruta completa para el workspace (si no la tiene)
                    if not file_path.startswith('/workspace/'):
                        workspace_path = f'/workspace/{filename}'
                    else:
                        workspace_path = file_path
                    
                    if filename.startswith('db2_results') and filename.endswith('.csv'):
                        # Buscar el archivo en ./tmp/db2/
                        # local_working_dir es ./tmp/code_interpreter_source
                        # Necesitamos ir a ./tmp/db2/
                        tmp_dir = os.path.dirname(self.storage.local_working_dir)
                        source_path = os.path.join(tmp_dir, 'db2', filename)
                        
                        if os.path.exists(source_path):
                            # Calcular hash del archivo
                            with open(source_path, 'rb') as f:
                                file_hash = hashlib.sha256(f.read()).hexdigest()
                            
                            # Copiar al interpreter_working_dir con el hash como nombre
                            dest_path = os.path.join(self.storage.interpreter_working_dir, file_hash)
                            shutil.copy2(source_path, dest_path)
                            
                            # Agregar al dict de files con la ruta completa del workspace
                            files_dict[workspace_path] = file_hash
                        else:
                            # Si no existe el archivo, informar al agente
                            raise ToolError(
                                f"CSV file not found: {filename}. "
                                f"Make sure the file exists in ./tmp/db2/ directory. "
                                f"DB2Tool should have generated this file after running a query."
                            )
                    else:
                        # Para otros archivos, asumir que el hash es el basename
                        file_hash = filename
                        files_dict[workspace_path] = file_hash
                
                if files_dict:
                    payload["files"] = files_dict
            
            # Hacer la request al code interpreter
            async with httpx.AsyncClient(timeout=60.0) as client:
                response = await client.post(
                    self.execute_endpoint,
                    json=payload,
                    headers={"Content-Type": "application/json"}
                )
                response.raise_for_status()
                
                result = response.json()
                
                # Obtener archivos generados (dict con filename: hash)
                files_dict = result.get("files", {})
                
                # Copiar archivos generados del interpreter al source (si hay storage configurado)
                if self.storage and files_dict:
                    for filename, file_hash in files_dict.items():
                        # Archivo en interpreter_working_dir
                        src_path = os.path.join(self.storage.interpreter_working_dir, file_hash)
                        # Copiar a local_working_dir
                        if os.path.exists(src_path):
                            # Extraer el nombre base del archivo (ej: /workspace/plot.png -> plot.png)
                            base_filename = os.path.basename(filename)
                            dst_path = os.path.join(self.storage.local_working_dir, base_filename)
                            shutil.copy2(src_path, dst_path)
                
                # Construir el output en formato texto
                output_parts = []
                
                # Agregar stdout si hay
                if result.get("stdout"):
                    output_parts.append(f"{result['stdout']}")
                
                # Agregar stderr si hay
                if result.get("stderr"):
                    output_parts.append(f"Errors:\n{result['stderr']}")
                
                # Agregar exit code si hay error
                exit_code = result.get("exit_code", 0)
                if exit_code != 0:
                    output_parts.append(f"Exit code: {exit_code}")
                
                # Agregar información sobre archivos generados en el formato específico
                if files_dict:
                    file_lines = []
                    for filename, file_hash in files_dict.items():
                        # Extraer nombre base del archivo
                        base_filename = os.path.basename(filename)
                        
                        # Detectar tipo de archivo por extensión
                        file_ext = base_filename.lower().split('.')[-1] if '.' in base_filename else ''
                        
                        # Para imágenes: usar formato ![name](urn:...) para mostrar inline
                        # Para otros archivos: usar formato [name](urn:...) solo para referencia
                        if file_ext in ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg']:
                            # Formato de imagen: se mostrará inline
                            file_lines.append(f"![{base_filename}](urn:bee:file:{file_hash})")
                        else:
                            # Formato de archivo: solo referencia (CSV, PDF, etc.)
                            file_lines.append(f"[{base_filename}](urn:bee:file:{file_hash})")
                    
                    files_output = (
                        "SUCCESS: Files were created. "
                        "IMPORTANT: To show these files to the user, you MUST copy the EXACT markdown below into your final answer. "
                        "DO NOT modify it, DO NOT create your own URLs, DO NOT add extra text. "
                        "Just copy this EXACTLY as-is:\n\n" + 
                        "\n".join(file_lines) +
                        "\n\nRemember: Use the markdown EXACTLY as shown above. The system will convert it to the correct URL automatically."
                    )
                    output_parts.append(files_output)
                
                # Si no hay output en absoluto, indicarlo
                if not output_parts:
                    output_parts.append("Code executed successfully (no output)")
                
                output_text = "\n\n".join(output_parts)
                
                # Crear el output con metadata de archivos
                tool_output = StringToolOutput(output_text)
                # Agregar metadata de archivos generados para acceso posterior (solo los hashes)
                tool_output.generated_files = list(files_dict.values())  # type: ignore
                
                return tool_output
                
        except httpx.HTTPStatusError as e:
            raise ToolError(
                f"Code interpreter returned error {e.response.status_code}: {e.response.text}"
            ) from e
        except httpx.RequestError as e:
            raise ToolError(
                f"Failed to connect to code interpreter at {self.execute_endpoint}: {str(e)}"
            ) from e
        except Exception as e:
            raise ToolError(f"Unexpected error executing Python code: {str(e)}") from e

